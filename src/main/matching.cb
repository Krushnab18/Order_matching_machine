#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "../include/order.h"
#include "../include/order_book.h"
#include "../include/avl_tree.h"
// Helper function to create a matched order with specified quantity
Order *create_matched_order(Order *source, int quantity) {
    Order *matched_order = (Order *)malloc(sizeof(Order));
    memcpy(matched_order, source, sizeof(Order));
    matched_order->quantity = quantity;
    return matched_order;
}

// Function to process matched orders and update quantities
void process_match(Order *new_order, Order *existing_order, Order_book *orderBook) {
    int min_quantity = (new_order->quantity < existing_order->quantity) ? new_order->quantity : existing_order->quantity;
    Order *matched_order = create_matched_order(existing_order, min_quantity);

    addorder_to_orderBook(orderBook, new_order, matched_order);

    new_order->quantity -= min_quantity;
    existing_order->quantity -= min_quantity;

    free(matched_order);
}

// Function to match orders based on price, and insert remaining orders if no match
void insert_if_unmatched(buy_order_avl *buy_tree, sell_order_avl *sell_tree, Order *new_order, int is_buy_order) {
    if (is_buy_order) {
        insert_buy_order(buy_tree, new_order);
        printf("Inserted unmatched buy-order into buy_tree.\n");
    } else {
        insert_sell_order(sell_tree, new_order);
        printf("Inserted unmatched sell-order into sell_tree.\n");
    }
}

void matching_fifo(buy_order_avl *buy_tree, sell_order_avl *sell_tree, Order *new_order, Order_book *orderBook) {

    Node *temp = (new_order->side == 'B') ? sell_tree->root : buy_tree->root;
    int is_buy_order = (new_order->side == 'B');

    if (temp == NULL) { // If the opposing tree is empty
        insert_if_unmatched(buy_tree, sell_tree, new_order, is_buy_order);
        printf("No opposing orders available.\n");
        return;
    }

    int flag = 0; // To track if any match was found

    while (new_order->quantity > 0) {
        // Traverse to find the matching price
        while (temp != NULL && temp->order->price != new_order->price) {
            temp = (temp->order->price > new_order->price) ? temp->lchild : temp->rchild;
        }

        if (temp == NULL) { // No matching price found
            insert_if_unmatched(buy_tree, sell_tree, new_order, is_buy_order);
            if (flag == 0) printf("No match for the given order.\n");
            break;
        }

        // Process matching quantity
        flag = 1;
        process_match(new_order, temp->order, orderBook);

        if (temp->order->quantity == 0) { // Remove fully matched orders from tree
            if (is_buy_order) delete_sell_order(sell_tree, temp->order, &sell_tree->root);
            else delete_buy_order(buy_tree, temp->order, &buy_tree->root);
        }
        
        // Reset traversal from the root if remaining quantity exists
        temp = (is_buy_order) ? sell_tree->root : buy_tree->root;
    }

}
